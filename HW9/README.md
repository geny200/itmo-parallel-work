# HW 9

## Содержание

* Домашние работы
    * [**HW1**](./../HW1/README.md)
    * [**HW2**](./../HW2/README.md)
    * [**HW3**](./../HW3/README.md)
    * [**HW4**](./../HW4/README.md)
    * [**HW5**](./../HW5/README.md)
    * [**HW6**](./../HW6/README.md)
    * [**HW7**](./../HW7/README.md)
    * [**HW8**](./../HW8/README.md)
    * **HW9**
* Практические задания
    * [**CW1**](./../CW1/README.md)

## Task 1

Возьмите алгоритм подсчёта массива ID с лекции и сделайте так, чтобы он использовал O(n^{1 + eps}) (0 < eps < 1) памяти
вместо O(n^2), сохранив асимптотику work и span, если eps - константа. Подсказка: время работы изменится где-то в 1/eps
раз.

## Notes:

ID с лекции:

```python
for i = 0...|S|:
    ID[0][i] = S[i]

for it = 1...log|S|:
    pfor i = 0...|S|:
        BB[ID[it][i]][ID[it][i + 2^it]] = i
    pfor i = 0...|S|:
        ID[it][i] = BB[ID[it][i]][ID[it][i + 2^it]]
```

#### Решение

Используем вместо BB, например хэш таблицу (которая умеет исполнять запросы параллельно). Таким образом сократим память
до O(n), а асимптотически work и span останутся таким же (изменится только константа).

```python
for i = 0...|S|:
    ID[0][i] = S[i]

for it = 1...log|S|:
    pfor i = 0... |S|:
        hashMap[(ID[it][i], ID[it][i + 2 ^ it])] = i
    pfor i = 0...|S|:
        ID[it][i] = hashMap[(ID[it][i], ID[it][i + 2 ^ it])]
```
